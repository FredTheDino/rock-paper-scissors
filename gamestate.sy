use input
use assets
use gfx
use collision
from love use love
from main use new_gamepad

bool_to_int :: pu x: bool -> float
    if x do
        1.0
    else
        0.0
    end
end

ButtonState :: enum
    Up int
    Down int
end

PlayerInput :: blob {
    move: float,
    jump: ButtonState,
    trigger: ButtonState,
    shoot: int,
}

is_up :: pu x -> bool
    case x do
        Up _ -> true end
        Down _ -> false end
    end
end

is_down :: pu x -> bool
    not is_up(x)
end

pressed :: pu x, frame -> bool
    is_down(x) and get_frame(x) == frame
end

released :: pu x, frame -> bool
    (not is_down(x)) and get_frame(x) == frame
end


get_frame :: pu x -> int
    case x do
        Up n -> n end
        Down n -> n end
    end
end

held :: pu x, frame, diff -> bool
    is_down(x) and ((get_frame(x) + diff) >= frame)
end

player_size :: (20.0, 20.0)

Bullet :: blob {
    alive: bool,

    owner: int,
    lifetime: float,

    original_dir: (float, float),
    pos: (float, float),
    vel: (float, float),
}

bullet_hitbox_size :: (10.0, 10.0)

update_bullet :: fn bullet, delta do
    bullet.lifetime += delta
    bullet.pos += bullet.vel

    if bullet.lifetime > 0.4 do
        ss :: delta * 4.0
        bullet.vel -= bullet.original_dir * (ss, ss)
    end
end

draw_bullet :: fn bullet do
    color :: id_to_color' bullet.owner
    assets.banana.drawTintedCentered(color, bullet.pos, bullet.lifetime * 10.0, (0.1, 0.1))
    gfx.drawRectCenteredOutline(color, bullet.pos, bullet_hitbox_size)
end

explosion_from_bullet :: fn bullet ->
    Explosion {
        owner: bullet.owner,
        pos: bullet.pos,
        lifetime: 0.0,
    }
end

explosion_radius :: pu explosion ->
    max(0.0, 70.0 / (1.0 + explosion.lifetime) - 20.0)
end

inside_explosion_radius :: pu explosion, pos ->
    math.distance(pos, explosion.pos) < explosion_radius(explosion)
end

update_explosion :: fn explosion, state, delta do
    explosion.lifetime += delta

    if inside_explosion_radius(explosion, state.player_a.pos) do
        state.player_a.killed = state.frame
    elif state.player_a.killed == -1 do
        p :: state.player_a.pos
        d :: math.distance(p, explosion.pos) - explosion_radius(explosion)
        f :: 100.0 / (d)
        dir :: math.normalize(p - explosion.pos)
        state.player_a.vel += dir * (f, f)
    end

    if inside_explosion_radius(explosion, state.player_b.pos) do
        state.player_b.killed = state.frame
    end
end

draw_explosion :: fn explosion do
    color :: id_to_color' explosion.owner
    gfx.drawCircle' color, explosion.pos, explosion_radius' explosion
end

Explosion :: blob {
    owner: int,
    pos: (float, float),
    lifetime: float,
}

Player :: blob {
    id: int,
    pos: (float, float),
    vel: (float, float),
    size: (float, float),
    grounded: bool,
    killed: int,
    fired: int,

    bullets: [Bullet],

    input: PlayerInput,
}

new_player :: pu id: int ->
    Player {
        id: id,
        pos: list.get(spawns, id) -> maybe.orDefault((0.0, 0.0)),
        vel: (0.0, 0.0),
        size: (1.0, 1.0),
        grounded: true,
        killed: -1,
        fired: -1000,

        bullets: [],

        input: PlayerInput {
            move: 0.0,
            jump: ButtonState.Up -1,
            trigger: ButtonState.Up -1,
            shoot: 0,
        }
    }
end

read_input :: fn player, left, right, jump, trigger, gamepad, frame do
    inp := player.input
    num_bullets :: list.len' player.bullets
    grounded :: player.grounded
    fire_cooldown :: 10

    inp.move = math.clamp(
        bool_to_int(input.isKeyDown(right))
        - bool_to_int(input.isKeyDown(left))
        + gamepad.move,
        -1.0, 1.0
    )

    if ((input.isKeyDown(jump) or gamepad.jump) and is_up(inp.jump)) and grounded do
        inp.jump = ButtonState.Down frame
    elif not (input.isKeyDown(jump) or gamepad.jump) and not is_up(inp.jump) do
        inp.jump = ButtonState.Up frame
    end

    if num_bullets < 3 and player.fired + fire_cooldown < frame do
        if (not (input.isKeyDown(trigger) or gamepad.shoot) and not is_up(inp.trigger)) do
            inp.shoot = frame - get_frame(inp.trigger)
            inp.trigger = ButtonState.Up frame
        end
        if ((input.isKeyDown(trigger) or gamepad.shoot) and is_up(inp.trigger)) do
            inp.trigger = ButtonState.Down frame
        end
    end
end

update_player :: fn player, aim_dir, frame, delta do

    jump_force :: 350.0
    hover_force :: 1200.0
    move_force :: 2000.0
    gravity :: 2000.0

    player.vel += (player.input.move * move_force * delta, 0.0)
    if abs(player.input.move) > 0.1 do
        player.vel = (player.vel[0] * pow(0.0001, delta), player.vel[1])
    else
        player.vel = (player.vel[0] * pow(0.00001, delta), player.vel[1])
    end

    if pressed(player.input.jump, frame) do
        player.vel = (player.vel[0], -jump_force)
    elif held(player.input.jump, frame, 20) do
        player.vel += (0.0, -hover_force * delta)
    end
    player.vel += (0.0, gravity * delta)

    if released(player.input.trigger, frame) do
        player.fired = frame
        offset :: 25.0
        vel :: 5.0 + min(as_float(player.input.shoot) * 0.1, 5.0)
        player.bullets -> list.push(
            Bullet {
                owner: player.id,
                lifetime: 0.0,
                alive: true,

                original_dir: aim_dir,
                pos: player.pos + aim_dir * (offset, offset),
                vel: aim_dir * (vel, vel),

            }
        )
    end
    player.bullets -> for_each' fn bullet do
        update_bullet' bullet, delta
    end


    player.pos += player.vel * (delta, delta)

    floor :: 400.0
    if player.pos[1] >= floor do
        player.pos = (player.pos[0], floor)
        player.vel = (player.vel[0], min(0.0, player.vel[1]))
    end
end

id_to_color :: pu id ->
    if id == 0 do
        gfx.rgba(1.0, 0.2, 0.2, 0.5)
    else
        gfx.rgba(0.2, 0.8, 0.8, 0.5)
    end
end

draw_player :: fn player do
    if player.killed == -1 do
        color :: id_to_color' player.id
        gfx.drawRectCentered' color, player.pos, player_size
    end
    player.bullets -> for_each' draw_bullet
end

Camera :: blob {
    pos: (float, float),
}

new_camera :: fn a, b -> Camera
    camera :: Camera {
        pos: (0.0, 0.0),
    }
    update_camera' camera, 1.0, a, b
end

lerp :: pu f, a: float, b: float -> float
    (1.0 - f) * a + f * b
end

lerp_v2 :: pu f, a: (float, float), b: (float, float) -> (float, float)
    (lerp(f, a[0], b[0]), lerp(f, a[1], b[1]))
end

update_camera :: fn given, delta, a, b -> Camera
    half_screen :: (love.graphics.getWidth() / 2, love.graphics.getHeight() / 2)
    center :: (a.pos + b.pos) * (-0.5, -0.5)
    target :: center + half_screen

    Camera {
        pos: lerp_v2(delta * 1.0, given.pos, center * (1.0, 0.0) + half_screen + (0.0, 100.0)),
    }
end

push_camera :: fn camera do
    gfx.reset_camera()
    gfx.move_camera' camera.pos
end

// GS
GameState :: enum
    Playing
    Menu
end

State :: blob {
    current_state: GameState,
    frame: int,

    camera: Camera,
    explosions: [Explosion],

    player_a: Player,
    player_b: Player,
}

new :: fn ->
    player_a :: new_player(0)
    player_b :: new_player(1)
    State {
        current_state: GameState.Playing,
        frame: 0,

        camera: new_camera(player_a, player_b),
        explosions: [],

        player_a: player_a,
        player_b: player_b,
    }
end

find_furthest_from :: pu points, a -> (float, float)
    point :: points -> list.fold' (0.0, (0.0, 0.0)), pu pos, out ->
        distance :: math.distance(pos, a)
        if distance > out[0] do
            (distance, pos)
        else
            out
        end
    end
    point[1]
end

chain :: fn a: [*A], b: [*A], f: fn *A -> void do
    a -> list.for_each' f
    b -> list.for_each' f
end

update :: fn state: State, delta: float, gamepads -> State
    case state.current_state do
        Playing ->
            all_alive :: state.player_a.killed == -1 and state.player_b.killed == -1
            if (not all_alive) and (state.player_a.killed + 60 == state.frame or state.player_b.killed + 60 == state.frame) do
                state.player_a.bullets = []
                state.player_b.bullets = []

                state.explosions = []

                state.player_a = new_player(state.player_a.id)
                state.player_a.pos = list.random_choice(spawns) -> maybe.orDefault((0.0, 0.0))

                state.player_b = new_player(state.player_b.id)
                state.player_b.pos = find_furthest_from' spawns, state.player_a.pos
            else
                state.player_a.input.move = 0.0
                state.player_b.input.move = 0.0
            end

            push_wall :: 320.0
            if abs(state.player_a.pos[0]) > push_wall do
                x :: state.player_a.pos[0]
                dx :: (abs(x) - push_wall) * delta * 60.0
                state.player_a.vel -= (sign(x) * dx, 0.0)
            end

            if abs(state.player_b.pos[0]) > push_wall do
                x :: state.player_b.pos[0]
                dx :: (abs(x) - push_wall) * delta * 60.0
                state.player_b.vel -= (sign(x) * dx, 0.0)
            end

            if all_alive do
                read_input( state.player_a
                          , input.Key.A, input.Key.D
                          , input.Key.W, input.Key.S
                          , dict.get(gamepads, state.player_a.id) -> maybe.orDefault(new_gamepad())
                          , state.frame )

                read_input( state.player_b
                          , input.Key.Left, input.Key.Right
                          , input.Key.Up, input.Key.Down
                          , dict.get(gamepads, state.player_b.id) -> maybe.orDefault(new_gamepad())
                          , state.frame )
            end

            aim :: math.normalize(state.player_b.pos - state.player_a.pos)
            update_player(state.player_a, aim, state.frame, delta)
            aim :: math.normalize(state.player_a.pos - state.player_b.pos)
            update_player(state.player_b, aim, state.frame, delta)


            state.player_a.grounded = false
            state.player_b.grounded = false
            ground -> for_each' fn g do
                collision_with_player(state.player_a, g)
                collision_with_player(state.player_b, g)

                check_bullet_collison :: fn b do
                    if (b.lifetime > 3.0
                    or (0.0, 0.0) != collision.box_vs_box(b.pos, bullet_hitbox_size, g[0], g[1])
                    or (0.0, 0.0) != collision.box_vs_box(b.pos, bullet_hitbox_size, state.player_a.pos, player_size)
                    or (0.0, 0.0) != collision.box_vs_box(b.pos, bullet_hitbox_size, state.player_b.pos, player_size)) do
                        b.alive = false
                        ret
                    end
                    state.explosions -> list.for_each' fn x do
                        if inside_explosion_radius' x, b.pos do
                            b.alive = false
                        end
                    end
                end

                state.player_a.bullets -> list.for_each' check_bullet_collison
                state.player_b.bullets -> list.for_each' check_bullet_collison

                chain' state.player_a.bullets, state.player_b.bullets, fn a do
                    chain' state.player_a.bullets, state.player_b.bullets, fn b do
                        if (0.0, 0.0) != collision.box_vs_box( b.pos, bullet_hitbox_size
                                                             , a.pos, bullet_hitbox_size) do
                            a.alive = false
                            b.alive = false
                        end
                    end
                end

                add_explosion :: fn a do
                    if not a.alive do
                        list.push(state.explosions, explosion_from_bullet(a))
                    end
                end

                state.player_a.bullets -> list.for_each' add_explosion
                state.player_b.bullets -> list.for_each' add_explosion

                state.player_a.bullets = state.player_a.bullets -> list.filter' pu b -> b.alive end
                state.player_b.bullets = state.player_b.bullets -> list.filter' pu b -> b.alive end

                state.explosions -> list.for_each' fn x do update_explosion(x, state, delta) end
                state.explosions = state.explosions -> list.filter' pu x -> x.lifetime < 3.0 end
            end
            platform -> for_each' fn g do
                collision_with_player_platform(state.player_a, g)
                collision_with_player_platform(state.player_b, g)
            end

            state.camera = update_camera(state.camera, delta, state.player_a, state.player_b)
        end
        Menu ->
            if input.isKeyDown' input.Key.B do
                state.current_state = GameState.Playing
            end
        end
    end
    state.frame += 1


    state
end

ground :: [
    ((0.0, 0.0), (100.0, 20.0)),
    ((0.0, 20.0), (600.0, 20.0)),
    ((0.0, 20.0), (600.0, 20.0)),
    ((340.0, 10.0), (140.0, 40.0)),
    ((-340.0, 10.0), (140.0, 40.0)),

    ((0.0, -105.0), (40.0, 40.0)),
]

hh :: 10.0
platform :: [
    ((150.0, -40.0), (100.0, hh)),
    ((-150.0, -40.0), (100.0, hh)),

    ((0.0, -90.0), (200.0, hh)),

    ((240.0, -90.0), (100.0, hh)),
    ((-240.0, -90.0), (100.0, hh)),

    ((150.0, -140.0), (100.0, hh)),
    ((-150.0, -140.0), (100.0, hh)),
]

spawns :: [
    (-300.0, -20.0),
    (300.0, -20.0),

    (-150.0, 0.0),
    (150.0, 0.0),
    (-0.0, -40.0),
]

collision_with_player :: fn player, object do
    dim :: collision.box_vs_box(player.pos, player_size, object[0], object[1])
    if dim[0] != 0.0 or dim[1] != 0.0 do
        player.pos -= dim

        dv :: if dim[0] != 0.0 do
            (player.vel[0], 0.0)
        elif dim[1] != 0.0 do
            (0.0, player.vel[1])
        else do
            (0.0, 0.0)
        end
        player.vel -= dv

        if dim[1] > 0 do
            player.grounded = true
        end
    end
end

collision_with_player_platform :: fn player, object do
    dim :: collision.box_vs_box(player.pos, player_size, object[0], object[1])
    if dim[0] == 0.0 and dim[1] > 0.0 and player.vel[1] >= 0.0 do
        player.pos -= dim

        dv :: if dim[0] != 0.0 do
            (player.vel[0], 0.0)
        else
            (0.0, player.vel[1])
        end
        player.vel -= dv

        if dim[1] > 0 do
            player.grounded = true
        end
    end
end


draw_object :: fn object, color do
    gfx.drawRectCentered' color, object[0], object[1]
end

draw :: fn state: State do
    case state.current_state do
        Playing ->
            push_camera' state.camera

            draw_player(state.player_a)
            draw_player(state.player_b)

            ground -> for_each' fn g do
                draw_object(g, gfx.rgba(1.0, 1.0, 1.0, 1.0))
            end

            platform -> for_each' fn g do
                draw_object(g, gfx.rgba(1.0, 1.0, 1.0, 0.5))
            end

            state.explosions -> list.for_each' draw_explosion
        end
        Menu ->
        end
    end
end

