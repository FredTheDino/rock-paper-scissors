use input
use assets
use gfx
use collision
from love use love
from main use new_gamepad

bool_to_int :: pu x: bool -> float
    if x do
        1.0
    else
        0.0
    end
end

ButtonState :: enum
    Up int
    Down int
end

PlayerInput :: blob {
    move: float,
    jump: ButtonState,
    trigger: ButtonState,
    shoot: int,

}

is_up :: pu x -> bool
    case x do
        Up _ -> true end
        Down _ -> false end
    end
end

is_down :: pu x -> bool
    not is_up(x)
end

pressed :: pu x, frame -> bool
    is_down(x) and get_frame(x) == frame
end

released :: pu x, frame -> bool
    (not is_down(x)) and get_frame(x) == frame
end


get_frame :: pu x -> int
    case x do
        Up n -> n end
        Down n -> n end
    end
end

held :: pu x, frame, diff -> bool
    is_down(x) and ((get_frame(x) + diff) >= frame)
end

player_size :: (20.0, 20.0)

Bullet :: blob {
    owner: int,
    lifetime: float,

    original_dir: (float, float),
    pos: (float, float),
    vel: (float, float),
}

bullet_hitbox_size :: (10.0, 10.0)

update_bullet :: fn bullet, delta do
    bullet.lifetime += delta
    bullet.pos += bullet.vel

    if 1.5 < bullet.lifetime do
        bullet.vel += (0.0, 10.0 * delta)
    end

    if 0.1 < bullet.lifetime and bullet.lifetime < 2.0 do
        bullet.vel -= bullet.original_dir * (8.0, 8.0) * (delta, delta)
    end
end

draw_bullet :: fn bullet do
    color :: id_to_color' bullet.owner
    assets.banana.drawTintedCentered(color, bullet.pos, bullet.lifetime * 10.0, (0.1, 0.1))
    gfx.drawRectCenteredOutline(color, bullet.pos, bullet_hitbox_size)
end

Player :: blob {
    id: int,
    pos: (float, float),
    vel: (float, float),
    size: (float, float),
    grounded: bool,
    throwDir: bool,
    alive: bool,

    bullets: [Bullet],

    input: PlayerInput,
}

new_player :: pu id: int ->
    Player {
        id: id,
        pos: list.get(spawns, id) -> maybe.orDefault((0.0, 0.0)),
        vel: (0.0, 0.0),
        size: (1.0, 1.0),
        grounded: true,
        alive: true,
        throwDir: false,

        bullets: [],

        input: PlayerInput {
            move: 0.0,
            jump: ButtonState.Up -1,
            trigger: ButtonState.Up -1,
            shoot: 0,
        }
    }
end

read_input :: fn inp, left, right, jump, trigger, grounded, num_bullets, gamepad, frame do
    inp.move = math.clamp(
        bool_to_int(input.isKeyDown(right))
        - bool_to_int(input.isKeyDown(left))
        + gamepad.move,
        -1.0, 1.0
    )

    if ((input.isKeyDown(jump) or gamepad.jump) and is_up(inp.jump)) and grounded do
        inp.jump = ButtonState.Down frame
    elif not (input.isKeyDown(jump) or gamepad.jump) and not is_up(inp.jump) do
        inp.jump = ButtonState.Up frame
    end

    if num_bullets < 3 do
        if (not (input.isKeyDown(trigger) or gamepad.shoot) and not is_up(inp.trigger)) do
            inp.shoot = frame - get_frame(inp.trigger)
            inp.trigger = ButtonState.Up frame
        end
        if ((input.isKeyDown(trigger) or gamepad.shoot) and is_up(inp.trigger)) do
            inp.trigger = ButtonState.Down frame
        end
    end
end

update_player :: fn player, aim_dir, frame, delta do

    jump_force :: 400.0
    hover_force :: 1200.0
    move_force :: 1000.0
    gravity :: 3000.0

    player.vel += (player.input.move * move_force * delta, 0.0)
    if abs(player.input.move) > 0.1 do
        player.vel = (player.vel[0] * pow(0.01, delta), player.vel[1])
    else
        player.vel = (player.vel[0] * pow(0.0001, delta), player.vel[1])
    end

    if pressed(player.input.jump, frame) do
        player.vel += (0.0, -jump_force)
    elif held(player.input.jump, frame, 20) do
        player.vel += (0.0, -hover_force * delta)
    end
    player.vel += (0.0, gravity * delta)

    if released(player.input.trigger, frame) do
        dir :: if player.throwDir do 1.0 else -1.0 end
        aim_dir :: (dir, dir) * aim_dir
        offset :: 20.0
        vel :: 3.0 + min(as_float(player.input.shoot) * 0.1, 5.0)
        player.bullets -> list.push(
            Bullet {
                owner: player.id,
                lifetime: 0.0,

                original_dir: aim_dir,
                pos: player.pos + aim_dir * (offset, offset),
                vel: aim_dir * (vel, vel),

            }
        )

        player.throwDir = not player.throwDir
    end
    player.bullets -> for_each' fn bullet do
        update_bullet' bullet, delta
    end


    player.pos += player.vel * (delta, delta)

    floor :: 400.0
    if player.pos[1] >= floor do
        player.pos = (player.pos[0], floor)
        player.vel = (player.vel[0], min(0.0, player.vel[1]))
    end
end

id_to_color :: pu id ->
    if id == 0 do
        gfx.rgba(1.0, 0.2, 0.2, 0.5)
    else
        gfx.rgba(0.2, 0.8, 0.8, 0.5)
    end
end

draw_player :: fn player do
    if player.alive do
        color :: id_to_color' player.id
        gfx.drawRectCentered' color, player.pos, player_size
    end
    player.bullets -> for_each' draw_bullet
end

Camera :: blob {
    pos: (float, float),
}

new_camera :: fn a, b -> Camera
    camera :: Camera {
        pos: (0.0, 0.0),
    }
    update_camera' camera, 1.0, a, b
end

lerp :: pu f, a: float, b: float -> float
    (1.0 - f) * a + f * b
end

lerp_v2 :: pu f, a: (float, float), b: (float, float) -> (float, float)
    (lerp(f, a[0], b[0]), lerp(f, a[1], b[1]))
end

update_camera :: fn given, delta, a, b -> Camera
    half_screen :: (love.graphics.getWidth() / 2, love.graphics.getHeight() / 2)
    center :: (a.pos + b.pos) * (-0.5, -0.5)
    target :: center + half_screen

    Camera {
        pos: lerp_v2(delta * 1.0, given.pos, center * (1.0, 0.0) + half_screen + (0.0, 100.0)),
    }
end

push_camera :: fn camera do
    gfx.reset_camera()
    gfx.move_camera' camera.pos
end

// GS
GameState :: enum
    Playing
    Menu
end

State :: blob {
    current_state: GameState,
    frame: int,

    camera: Camera,

    player_a: Player,
    player_b: Player,
}

new :: fn ->
    player_a :: new_player(0)
    player_b :: new_player(1)
    State {
        current_state: GameState.Playing,
        frame: 0,

        camera: new_camera(player_a, player_b),

        player_a: player_a,
        player_b: player_b,
    }
end

find_furthest_from :: pu points, a -> (float, float)
    point :: points -> list.fold' (0.0, (0.0, 0.0)), pu pos, out ->
        distance :: math.distance(pos, a)
        if distance > out[0] do
            (distance, pos)
        else
            out
        end
    end
    point[1]
end

update :: fn state: State, delta: float, gamepads -> State
    case state.current_state do
        Playing ->
            read_input( state.player_a.input
                      , input.Key.A, input.Key.D
                      , input.Key.W, input.Key.S
                      , state.player_a.grounded
                      , list.len(state.player_a.bullets)
                      , dict.get(gamepads, state.player_a.id) -> maybe.orDefault(new_gamepad())
                      , state.frame )

            read_input( state.player_b.input
                      , input.Key.Left, input.Key.Right
                      , input.Key.Up, input.Key.Down
                      , state.player_b.grounded
                      , list.len(state.player_a.bullets)
                      , dict.get(gamepads, state.player_b.id) -> maybe.orDefault(new_gamepad())
                      , state.frame )

            if not state.player_a.alive do
                state.player_a.bullets = []
                state.player_b.bullets = []

                state.player_a = new_player(state.player_a.id)
                state.player_a.pos = find_furthest_from' spawns, state.player_b.pos
            end

            other_player_pos :: state.player_a.pos
            if not state.player_b.alive do
                state.player_a.bullets = []
                state.player_b.bullets = []

                state.player_b = new_player(state.player_b.id)
                state.player_b.pos = find_furthest_from' spawns, state.player_a.pos
            end


            aim :: math.normalize(state.player_b.pos - state.player_a.pos)
            update_player(state.player_a, aim, state.frame, delta)
            aim :: math.normalize(state.player_a.pos - state.player_b.pos)
            update_player(state.player_b, aim, state.frame, delta)

           state.player_a.grounded = false
            state.player_b.grounded = false
            ground -> for_each' fn g do
                collision_with_player(state.player_a, g)
                collision_with_player(state.player_b, g)

                state.player_a.bullets = state.player_a.bullets -> list.filter' pu b ->
                    b.lifetime > 3.0 or (0.0, 0.0) == collision.box_vs_box(b.pos, bullet_hitbox_size, g[0], g[1])
                end
                state.player_b.bullets = state.player_b.bullets -> list.filter' pu b ->
                    b.lifetime > 3.0 or (0.0, 0.0) == collision.box_vs_box(b.pos, bullet_hitbox_size, g[0], g[1])
                end

                state.player_a.bullets -> list.for_each' fn b do
                    if (0.0, 0.0) != collision.box_vs_box(b.pos, bullet_hitbox_size, state.player_a.pos, player_size) do
                        state.player_a.alive = false
                    end
                    if (0.0, 0.0) != collision.box_vs_box(b.pos, bullet_hitbox_size, state.player_b.pos, player_size) do
                        state.player_b.alive = false
                    end
                end
                state.player_b.bullets -> list.for_each' fn b do
                    if (0.0, 0.0) != collision.box_vs_box(b.pos, bullet_hitbox_size, state.player_a.pos, player_size) do
                        state.player_a.alive = false
                    end
                    if (0.0, 0.0) != collision.box_vs_box(b.pos, bullet_hitbox_size, state.player_b.pos, player_size) do
                        state.player_b.alive = false
                    end
                end
            end
            platform -> for_each' fn g do
                collision_with_player_platform(state.player_a, g)
                collision_with_player_platform(state.player_b, g)
            end

            state.camera = update_camera(state.camera, delta, state.player_a, state.player_b)
        end
        Menu ->
            if input.isKeyDown' input.Key.B do
                state.current_state = GameState.Playing
            end
        end
    end
    state.frame += 1


    state
end

ground :: [
    ((0.0, 0.0), (100.0, 20.0)),
    ((0.0, 20.0), (600.0, 20.0)),
    ((0.0, 20.0), (600.0, 20.0)),
    ((300.0, 10.0), (100.0, 40.0)),
    ((-300.0, 10.0), (100.0, 40.0)),

    ((-370.0, -180.0), (40.0, 400.0)),
    ((370.0, -180.0), (40.0, 400.0)),
]

platform :: [
    ((150.0, -30.0), (100.0, 10.0)),
    ((-150.0, -30.0), (100.0, 10.0)),
]

spawns :: [
    (-300.0, -20.0),
    (300.0, -20.0),

    (-150.0, 0.0),
    (150.0, 0.0),
    (-0.0, -40.0),
]

collision_with_player :: fn player, object do
    dim :: collision.box_vs_box(player.pos, player_size, object[0], object[1])
    if dim[0] != 0.0 or dim[1] != 0.0 do
        player.pos -= dim

        dv :: if dim[0] != 0.0 do
            (player.vel[0], 0.0)
        elif dim[1] != 0.0 do
            (0.0, player.vel[1])
        else do
            (0.0, 0.0)
        end
        player.vel -= dv

        if dim[1] > 0 do
            player.grounded = true
        end
    end
end

collision_with_player_platform :: fn player, object do
    dim :: collision.box_vs_box(player.pos, player_size, object[0], object[1])
    if dim[0] == 0.0 and dim[1] > 0.0 and player.vel[1] >= 0.0 do
        player.pos -= dim

        dv :: if dim[0] != 0.0 do
            (player.vel[0], 0.0)
        else
            (0.0, player.vel[1])
        end
        player.vel -= dv

        if dim[1] > 0 do
            player.grounded = true
        end
    end
end


draw_object :: fn object, color do
    gfx.drawRectCentered' color, object[0], object[1]
end

draw :: fn state: State do
    case state.current_state do
        Playing ->
            push_camera' state.camera

            draw_player(state.player_a)
            draw_player(state.player_b)

            ground -> for_each' fn g do
                draw_object(g, gfx.rgba(1.0, 1.0, 1.0, 1.0))
            end

            platform -> for_each' fn g do
                draw_object(g, gfx.rgba(1.0, 1.0, 1.0, 0.5))
            end
        end
        Menu ->
        end
    end
end

