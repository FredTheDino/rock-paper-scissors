use input
use assets
use gfx
use collision

bool_to_int :: pu x: bool -> float
    if x do
        1.0
    else
        0.0
    end
end

ButtonState :: enum
    Up int
    Down int
end

PlayerInput :: blob {
    move: float,
    jump: ButtonState,
    charge: ButtonState,
}

is_up :: pu x -> bool
    case x do
        Up _ -> true end
        Down _ -> false end
    end
end

is_down :: pu x -> bool
    not is_up(x)
end

pressed :: pu x, frame -> bool
    is_down(x) and get_frame(x) == frame
end

get_frame :: pu x -> int
    case x do
        Up n -> n end
        Down n -> n end
    end
end

held :: pu x, frame, diff -> bool
    is_down(x) and ((get_frame(x) + diff) >= frame)
end

player_size :: (20.0, 20.0)

Player :: blob {
    id: int,
    pos: (float, float),
    vel: (float, float),
    size: (float, float),

    input: PlayerInput,
}

new_player :: pu id: int ->
    Player {
        id: id,
        pos: (100.0 + as_float(id), 0.0),
        vel: (0.0, 0.0),
        size: (1.0, 1.0),

        input: PlayerInput {
            move: 0.0,
            jump: ButtonState.Up 0,
            charge: ButtonState.Up 0,
        }
    }
end

read_input :: fn inp, left, right, jump, charge, frame do
    inp.move = (
        bool_to_int(input.isKeyDown(right))
        - bool_to_int(input.isKeyDown(left))
    )

    if input.isKeyDown(jump) and is_up(inp.jump) do
        inp.jump = ButtonState.Down frame
    end
    if not input.isKeyDown(jump) and not is_up(inp.jump) do
        inp.jump = ButtonState.Up frame
    end

    if input.isKeyDown(charge) and is_up(inp.charge) do
        inp.charge = ButtonState.Down frame
    end
    if not input.isKeyDown(charge) and not is_up(inp.charge) do
        inp.charge = ButtonState.Up frame
    end
end

update_player :: fn player, frame, delta do
    jump_force :: 300.0
    hover_force :: 500.0
    move_force :: 1000.0
    gravity :: 1000.0

    player.vel += (player.input.move * move_force * delta, 0.0)
    if abs(player.input.move) > 0.1 do
        player.vel = (player.vel[0] * pow(0.01, delta), player.vel[1])
    else
        player.vel = (player.vel[0] * pow(0.0001, delta), player.vel[1])
    end

    if pressed(player.input.jump, frame) do
        player.vel += (0.0, -jump_force)
    elif held(player.input.jump, frame, 20) do
        player.vel += (0.0, -hover_force * delta)
    end
    player.vel += (0.0, gravity * delta)

    player.pos += player.vel * (delta, delta)

    floor :: 400.0
    if player.pos[1] >= floor do
        player.pos = (player.pos[0], floor)
        player.vel = (player.vel[0], min(0.0, player.vel[1]))
    end
end

draw_player :: fn player do
    color :: if player.id == 0 do
        gfx.rgba(1.0, 0.2, 0.2, 0.5)
    else
        gfx.rgba(0.2, 0.8, 0.8, 0.5)
    end
    gfx.drawRectCentered' color, player.pos, player_size
end

// GS
GameState :: enum
    Playing
    Menu
end

State :: blob {
    current_state: GameState,
    frame: int,

    player_a: Player,
    player_b: Player,
}

new :: fn ->
    State {
        current_state: GameState.Playing,
        frame: 0,

        player_a: new_player(0),
        player_b: new_player(1),
    }
end

update :: fn state: State, delta: float -> State
    case state.current_state do
        Playing ->
            read_input( state.player_a.input
                      , input.Key.A, input.Key.D
                      , input.Key.W, input.Key.S
                      , state.frame )

            read_input( state.player_b.input
                      , input.Key.Left, input.Key.Right
                      , input.Key.Up, input.Key.Down
                      , state.frame )

            update_player(state.player_a, state.frame, delta)
            update_player(state.player_b, state.frame, delta)

            collision_with_player(state.player_a, ground)
            collision_with_player(state.player_b, ground)
        end
        Menu ->
            if input.isKeyDown' input.Key.B do
                state.current_state = GameState.Playing
            end
        end
    end
    state.frame += 1

    state
end

ground :: ((100.0, 100.0), (100.0, 20.0))

collision_with_player :: fn player, object do
    dim :: collision.box_vs_box(player.pos, player_size, object[0], object[1])
    if dim[0] != 0.0 or dim[1] != 0.0 do
        player.pos -= dim

        dv :: if dim[0] != 0.0 do
            (player.vel[0], 0.0)
        else
            (0.0, player.vel[1])
        end
        player.vel -= dv
    end
end

draw_object :: fn object do
    gfx.drawRectCentered' gfx.rgb(1.0, 1.0, 1.0), object[0], object[1]
end

draw :: fn state: State do
    case state.current_state do
        Playing ->
            draw_player(state.player_a)
            draw_player(state.player_b)

            draw_object(ground)
        end
        Menu ->
        end
    end
end

